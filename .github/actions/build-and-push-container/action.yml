# This action assumes the parent workflow has already logged into AWS ECR and
#  has handled authentication and is providing the metadata generated by docker/metadata-action
name: Build and push container
description: Build and push a container to AWS ECR
inputs:
  AWS_ECR_REPOSITORY:
    description: AWS ECR Repository
    required: true
  PLATFORMS:
    description: What platforms to build for (Comma separated)
    required: false
    default: linux/amd64
  DOCKERFILE:
    description: Dockerfile to use (Either BUILD_CONTEXT or DOCKERFILE or both must be specified)
    required: false
    default: BUILD_CONTEXT/Dockerfile
  BUILD_CONTEXT:
    description: Build context used by the docker builder (. to reference top of Git repo, DOCKERFILE_DIRNAME to reference Dockerfile directory - Either BUILD_CONTEXT or DOCKERFILE or both must be specified)
    required: false
    default: DOCKERFILE_DIRNAME
  BUILD_ARGS:
    description: Build arguments to pass to the docker builder (Newline separated string of KEY=VAR)
    required: false
    default: ''
  ARTIFACTS:
    description: Comma separated list of artifacts within the container to upload as build artifacts (Debug logs etc)
    required: false
    default: ''
  METADATA:
    description: Metadata as generated by the docker/metadata-action (JSON-stringified)
    required: false
    default: ''

outputs:
  tags:
    description: The tags of the built images
    value: ${{ steps.tags.outputs.value }}

runs:
  using: composite
  steps:
    - name: Set up QEMU
      id: qemu
      uses: docker/setup-qemu-action@v2
      with:
        image: tonistiigi/binfmt:latest
        platforms: all

    - name: Set up Docker Buildx
      id: buildx
      uses: docker/setup-buildx-action@v2
      with:
        # We're using an experimental version of buildx for s3 support
        driver-opts: image=moby/buildkit:master

    - name: Inspect builder
      run: |
        echo "Name:      ${{ steps.buildx.outputs.name }}"
        echo "Endpoint:  ${{ steps.buildx.outputs.endpoint }}"
        echo "Status:    ${{ steps.buildx.outputs.status }}"
        echo "Flags:     ${{ steps.buildx.outputs.flags }}"
        echo "Platforms: ${{ steps.buildx.outputs.platforms }}"
      shell: bash

    # Fail if both BUILD_CONTEXT and DOCKERFILE are set to defaults
    - name: Fail if both BUILD_CONTEXT and DOCKERFILE are set to defaults
      if: inputs.BUILD_CONTEXT == 'DOCKERFILE_DIRNAME' && inputs.DOCKERFILE == 'BUILD_CONTEXT/Dockerfile'
      run: |
        echo "ERROR: BUILD_CONTEXT and DOCKERFILE are both set to defaults - please set one of them"
        exit 1
      shell: bash

    - run: |
        if [ "${{ inputs.BUILD_CONTEXT }}" == "DOCKERFILE_DIRNAME" ]; then
          BUILD_CONTEXT=$(dirname "${{ inputs.DOCKERFILE }}")
        else
          BUILD_CONTEXT="${{ inputs.BUILD_CONTEXT }}"
        fi
        echo "value=${BUILD_CONTEXT}" | tee -a $GITHUB_OUTPUT
      shell: bash
      id: build-context-dirname

    - uses: bluwy/substitute-string-action@v2
      id: dockerfile
      with:
        _input-text: ${{ inputs.DOCKERFILE }}
      env:
        BUILD_CONTEXT: ${{ steps.build-context-dirname.outputs.value }}

    - run: |
        dockerfile="${{ steps.dockerfile.outputs.result }}"
        echo "value=${dockerfile//\//_}" | tee -a $GITHUB_OUTPUT
      id: dockerfile_underscored
      shell: bash

    - name: Push Container (${{ inputs.AWS_ECR_REPOSITORY }})
      if: success()
      id: build
      uses: docker/build-push-action@v3.2.0
      with:
        file: ${{ steps.dockerfile.outputs.result }}
        context: ${{ steps.build-context-dirname.outputs.value }}
        tags: ${{ fromJSON(inputs.METADATA).tags }}
        labels: ${{ fromJSON(inputs.METADATA).labels }}
        platforms: ${{ inputs.PLATFORMS }}
        builder: ${{ steps.buildx.outputs.name }}
        push: true
        pull: true
        # ECR doesn't support inline-cache manifests, so we use the experimental s3 cache instead
        # https://github.com/aws/containers-roadmap/issues/876
        # https://github.com/moby/buildkit#s3-cache-experimental
        # Use a separate scope per dockerfile to avoid conflicts
        cache-from: type=s3,region=eu-west-2,bucket=iea-shared-gthb-ctns,prefix=gha_docker_build_cache/${{ github.event.repository.name }}/${{ steps.dockerfile_underscored.outputs.value }}
        cache-to: type=s3,region=eu-west-2,bucket=iea-shared-gthb-ctns,prefix=gha_docker_build_cache/${{ github.event.repository.name }}/${{ steps.dockerfile_underscored.outputs.value }},mode=max
        build-args: ${{ inputs.BUILD_ARGS }}

    # - name: Get Artifacts From Container
    #   if: success() && inputs.ARTIFACTS != ''
    #   shell: bash
    #   id: output-dir
    #   run: |
    #     docker create --name temp ${{ inputs.AWS_ECR_REPOSITORY }}:${{ github.sha }}${{ inputs.TAG_SUFFIX }}
    #     # Remove spaces around commas, assuming the user doesn't have a file name with a space and a comma
    #     #  next to each other
    #     files=$(echo '${{ inputs.ARTIFACTS }}' | sed 's/\s*,\s*/,/g')
    #     output_dir=$(mktemp -d)
    #     # Replace commas with spaces, intentionally not using bash string manip
    #     #  because that breaks values with spaces
    #     for file in $files; do
    #       docker cp "temp:${file}" "${output_dir}/"
    #     done
    #     docker rm temp
    #     echo "value=${output_dir}" | tee -a $GITHUB_OUTPUT

    # - name: Upload Artifacts
    #   if: success() && inputs.ARTIFACTS != ''
    #   uses: actions/upload-artifact@v3
    #   with:
    #     name: ${{ steps.dockerfile_underscored.outputs.value }}
    #     path: ${{ steps.output-dir.outputs.value }}

    - name: Output tags
      if: success()
      shell: bash
      id: tags
      run: |
        tags=$(echo '${{ inputs.METADATA }}' | jq -r '.["image.name"] | split(",") | join("\n")')
        echo "value<<EOF" | tee -a $GITHUB_OUTPUT
        echo "${tags}" | tee -a $GITHUB_OUTPUT
        echo "EOF" | tee -a $GITHUB_OUTPUT
        for tag in $tags; do
          echo '- `'"${prefix}${tag}"'`' | tee -a $GITHUB_STEP_SUMMARY
        done
